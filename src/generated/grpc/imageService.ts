/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.29.3
 * source: imageService.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export enum DeviceType {
    PHONE = 0,
    TABLET = 1,
    LAPTOP = 2
}
export class EchoRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[2]];
    constructor(data?: any[] | ({
        name?: string;
    } & (({
        sharedSecret?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("sharedSecret" in data && data.sharedSecret != undefined) {
                this.sharedSecret = data.sharedSecret;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get sharedSecret() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set sharedSecret(value: string) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
    }
    get has_sharedSecret() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _sharedSecret() {
        const cases: {
            [index: number]: "none" | "sharedSecret";
        } = {
            0: "none",
            2: "sharedSecret"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        name?: string;
        sharedSecret?: string;
    }): EchoRequest {
        const message = new EchoRequest({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.sharedSecret != null) {
            message.sharedSecret = data.sharedSecret;
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            sharedSecret?: string;
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.sharedSecret != null) {
            data.sharedSecret = this.sharedSecret;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.name.length)
            writer.writeString(1, this.name);
        if (this.has_sharedSecret)
            writer.writeString(2, this.sharedSecret);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EchoRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EchoRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    message.sharedSecret = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EchoRequest {
        return EchoRequest.deserialize(bytes);
    }
}
export class EchoReply extends pb_1.Message {
    #one_of_decls: number[][] = [[3]];
    constructor(data?: any[] | ({
        message?: string;
        files?: string[];
        sharedSecretMissing?: boolean;
    } & (({
        override?: MetadataOverride;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("message" in data && data.message != undefined) {
                this.message = data.message;
            }
            if ("files" in data && data.files != undefined) {
                this.files = data.files;
            }
            if ("override" in data && data.override != undefined) {
                this.override = data.override;
            }
            if ("sharedSecretMissing" in data && data.sharedSecretMissing != undefined) {
                this.sharedSecretMissing = data.sharedSecretMissing;
            }
        }
    }
    get message() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set message(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get files() {
        return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set files(value: string[]) {
        pb_1.Message.setField(this, 2, value);
    }
    get override() {
        return pb_1.Message.getWrapperField(this, MetadataOverride, 3) as MetadataOverride;
    }
    set override(value: MetadataOverride) {
        pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_override() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get sharedSecretMissing() {
        return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
    }
    set sharedSecretMissing(value: boolean) {
        pb_1.Message.setField(this, 4, value);
    }
    get _override() {
        const cases: {
            [index: number]: "none" | "override";
        } = {
            0: "none",
            3: "override"
        };
        return cases[pb_1.Message.computeOneofCase(this, [3])];
    }
    static fromObject(data: {
        message?: string;
        files?: string[];
        override?: ReturnType<typeof MetadataOverride.prototype.toObject>;
        sharedSecretMissing?: boolean;
    }): EchoReply {
        const message = new EchoReply({});
        if (data.message != null) {
            message.message = data.message;
        }
        if (data.files != null) {
            message.files = data.files;
        }
        if (data.override != null) {
            message.override = MetadataOverride.fromObject(data.override);
        }
        if (data.sharedSecretMissing != null) {
            message.sharedSecretMissing = data.sharedSecretMissing;
        }
        return message;
    }
    toObject() {
        const data: {
            message?: string;
            files?: string[];
            override?: ReturnType<typeof MetadataOverride.prototype.toObject>;
            sharedSecretMissing?: boolean;
        } = {};
        if (this.message != null) {
            data.message = this.message;
        }
        if (this.files != null) {
            data.files = this.files;
        }
        if (this.override != null) {
            data.override = this.override.toObject();
        }
        if (this.sharedSecretMissing != null) {
            data.sharedSecretMissing = this.sharedSecretMissing;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.message.length)
            writer.writeString(1, this.message);
        if (this.files.length)
            writer.writeRepeatedString(2, this.files);
        if (this.has_override)
            writer.writeMessage(3, this.override, () => this.override.serialize(writer));
        if (this.sharedSecretMissing != false)
            writer.writeBool(4, this.sharedSecretMissing);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EchoReply {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EchoReply();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.message = reader.readString();
                    break;
                case 2:
                    pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                    break;
                case 3:
                    reader.readMessage(message.override, () => message.override = MetadataOverride.deserialize(reader));
                    break;
                case 4:
                    message.sharedSecretMissing = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EchoReply {
        return EchoReply.deserialize(bytes);
    }
}
export class FileListRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[3]];
    constructor(data?: any[] | ({
        files?: string[];
        filesWithHash?: string[];
    } & (({
        sharedSecret?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("files" in data && data.files != undefined) {
                this.files = data.files;
            }
            if ("filesWithHash" in data && data.filesWithHash != undefined) {
                this.filesWithHash = data.filesWithHash;
            }
            if ("sharedSecret" in data && data.sharedSecret != undefined) {
                this.sharedSecret = data.sharedSecret;
            }
        }
    }
    get files() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set files(value: string[]) {
        pb_1.Message.setField(this, 1, value);
    }
    get filesWithHash() {
        return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set filesWithHash(value: string[]) {
        pb_1.Message.setField(this, 2, value);
    }
    get sharedSecret() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set sharedSecret(value: string) {
        pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
    }
    get has_sharedSecret() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get _sharedSecret() {
        const cases: {
            [index: number]: "none" | "sharedSecret";
        } = {
            0: "none",
            3: "sharedSecret"
        };
        return cases[pb_1.Message.computeOneofCase(this, [3])];
    }
    static fromObject(data: {
        files?: string[];
        filesWithHash?: string[];
        sharedSecret?: string;
    }): FileListRequest {
        const message = new FileListRequest({});
        if (data.files != null) {
            message.files = data.files;
        }
        if (data.filesWithHash != null) {
            message.filesWithHash = data.filesWithHash;
        }
        if (data.sharedSecret != null) {
            message.sharedSecret = data.sharedSecret;
        }
        return message;
    }
    toObject() {
        const data: {
            files?: string[];
            filesWithHash?: string[];
            sharedSecret?: string;
        } = {};
        if (this.files != null) {
            data.files = this.files;
        }
        if (this.filesWithHash != null) {
            data.filesWithHash = this.filesWithHash;
        }
        if (this.sharedSecret != null) {
            data.sharedSecret = this.sharedSecret;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.files.length)
            writer.writeRepeatedString(1, this.files);
        if (this.filesWithHash.length)
            writer.writeRepeatedString(2, this.filesWithHash);
        if (this.has_sharedSecret)
            writer.writeString(3, this.sharedSecret);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileListRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileListRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                    break;
                case 2:
                    pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                    break;
                case 3:
                    message.sharedSecret = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FileListRequest {
        return FileListRequest.deserialize(bytes);
    }
}
export class FileExistenceResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        files?: string[];
        existences?: boolean[];
        hashes?: Uint8Array[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2, 3], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("files" in data && data.files != undefined) {
                this.files = data.files;
            }
            if ("existences" in data && data.existences != undefined) {
                this.existences = data.existences;
            }
            if ("hashes" in data && data.hashes != undefined) {
                this.hashes = data.hashes;
            }
        }
    }
    get files() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set files(value: string[]) {
        pb_1.Message.setField(this, 1, value);
    }
    get existences() {
        return pb_1.Message.getFieldWithDefault(this, 2, []) as boolean[];
    }
    set existences(value: boolean[]) {
        pb_1.Message.setField(this, 2, value);
    }
    get hashes() {
        return pb_1.Message.getFieldWithDefault(this, 3, []) as Uint8Array[];
    }
    set hashes(value: Uint8Array[]) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        files?: string[];
        existences?: boolean[];
        hashes?: Uint8Array[];
    }): FileExistenceResponse {
        const message = new FileExistenceResponse({});
        if (data.files != null) {
            message.files = data.files;
        }
        if (data.existences != null) {
            message.existences = data.existences;
        }
        if (data.hashes != null) {
            message.hashes = data.hashes;
        }
        return message;
    }
    toObject() {
        const data: {
            files?: string[];
            existences?: boolean[];
            hashes?: Uint8Array[];
        } = {};
        if (this.files != null) {
            data.files = this.files;
        }
        if (this.existences != null) {
            data.existences = this.existences;
        }
        if (this.hashes != null) {
            data.hashes = this.hashes;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.files.length)
            writer.writeRepeatedString(1, this.files);
        if (this.existences.length)
            writer.writePackedBool(2, this.existences);
        if (this.hashes.length)
            writer.writeRepeatedBytes(3, this.hashes);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileExistenceResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileExistenceResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                    break;
                case 2:
                    message.existences = reader.readPackedBool();
                    break;
                case 3:
                    pb_1.Message.addToRepeatedField(message, 3, reader.readBytes());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FileExistenceResponse {
        return FileExistenceResponse.deserialize(bytes);
    }
}
export class MetadataOverride extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        models?: Uint8Array;
        loras?: Uint8Array;
        controlNets?: Uint8Array;
        textualInversions?: Uint8Array;
        upscalers?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("models" in data && data.models != undefined) {
                this.models = data.models;
            }
            if ("loras" in data && data.loras != undefined) {
                this.loras = data.loras;
            }
            if ("controlNets" in data && data.controlNets != undefined) {
                this.controlNets = data.controlNets;
            }
            if ("textualInversions" in data && data.textualInversions != undefined) {
                this.textualInversions = data.textualInversions;
            }
            if ("upscalers" in data && data.upscalers != undefined) {
                this.upscalers = data.upscalers;
            }
        }
    }
    get models() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
    }
    set models(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get loras() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
    }
    set loras(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get controlNets() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
    }
    set controlNets(value: Uint8Array) {
        pb_1.Message.setField(this, 3, value);
    }
    get textualInversions() {
        return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
    }
    set textualInversions(value: Uint8Array) {
        pb_1.Message.setField(this, 4, value);
    }
    get upscalers() {
        return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
    }
    set upscalers(value: Uint8Array) {
        pb_1.Message.setField(this, 5, value);
    }
    static fromObject(data: {
        models?: Uint8Array;
        loras?: Uint8Array;
        controlNets?: Uint8Array;
        textualInversions?: Uint8Array;
        upscalers?: Uint8Array;
    }): MetadataOverride {
        const message = new MetadataOverride({});
        if (data.models != null) {
            message.models = data.models;
        }
        if (data.loras != null) {
            message.loras = data.loras;
        }
        if (data.controlNets != null) {
            message.controlNets = data.controlNets;
        }
        if (data.textualInversions != null) {
            message.textualInversions = data.textualInversions;
        }
        if (data.upscalers != null) {
            message.upscalers = data.upscalers;
        }
        return message;
    }
    toObject() {
        const data: {
            models?: Uint8Array;
            loras?: Uint8Array;
            controlNets?: Uint8Array;
            textualInversions?: Uint8Array;
            upscalers?: Uint8Array;
        } = {};
        if (this.models != null) {
            data.models = this.models;
        }
        if (this.loras != null) {
            data.loras = this.loras;
        }
        if (this.controlNets != null) {
            data.controlNets = this.controlNets;
        }
        if (this.textualInversions != null) {
            data.textualInversions = this.textualInversions;
        }
        if (this.upscalers != null) {
            data.upscalers = this.upscalers;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.models.length)
            writer.writeBytes(1, this.models);
        if (this.loras.length)
            writer.writeBytes(2, this.loras);
        if (this.controlNets.length)
            writer.writeBytes(3, this.controlNets);
        if (this.textualInversions.length)
            writer.writeBytes(4, this.textualInversions);
        if (this.upscalers.length)
            writer.writeBytes(5, this.upscalers);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MetadataOverride {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MetadataOverride();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.models = reader.readBytes();
                    break;
                case 2:
                    message.loras = reader.readBytes();
                    break;
                case 3:
                    message.controlNets = reader.readBytes();
                    break;
                case 4:
                    message.textualInversions = reader.readBytes();
                    break;
                case 5:
                    message.upscalers = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MetadataOverride {
        return MetadataOverride.deserialize(bytes);
    }
}
export class ImageGenerationRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [3], [13]];
    constructor(data?: any[] | ({
        scaleFactor?: number;
        hints?: HintProto[];
        prompt?: string;
        negativePrompt?: string;
        configuration?: Uint8Array;
        override?: MetadataOverride;
        keywords?: string[];
        user?: string;
        device?: DeviceType;
        contents?: Uint8Array[];
    } & (({
        image?: Uint8Array;
    }) | ({
        mask?: Uint8Array;
    }) | ({
        sharedSecret?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4, 9, 12], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("image" in data && data.image != undefined) {
                this.image = data.image;
            }
            if ("scaleFactor" in data && data.scaleFactor != undefined) {
                this.scaleFactor = data.scaleFactor;
            }
            if ("mask" in data && data.mask != undefined) {
                this.mask = data.mask;
            }
            if ("hints" in data && data.hints != undefined) {
                this.hints = data.hints;
            }
            if ("prompt" in data && data.prompt != undefined) {
                this.prompt = data.prompt;
            }
            if ("negativePrompt" in data && data.negativePrompt != undefined) {
                this.negativePrompt = data.negativePrompt;
            }
            if ("configuration" in data && data.configuration != undefined) {
                this.configuration = data.configuration;
            }
            if ("override" in data && data.override != undefined) {
                this.override = data.override;
            }
            if ("keywords" in data && data.keywords != undefined) {
                this.keywords = data.keywords;
            }
            if ("user" in data && data.user != undefined) {
                this.user = data.user;
            }
            if ("device" in data && data.device != undefined) {
                this.device = data.device;
            }
            if ("contents" in data && data.contents != undefined) {
                this.contents = data.contents;
            }
            if ("sharedSecret" in data && data.sharedSecret != undefined) {
                this.sharedSecret = data.sharedSecret;
            }
        }
    }
    get image() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
    }
    set image(value: Uint8Array) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_image() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get scaleFactor() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set scaleFactor(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get mask() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
    }
    set mask(value: Uint8Array) {
        pb_1.Message.setOneofField(this, 3, this.#one_of_decls[1], value);
    }
    get has_mask() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get hints() {
        return pb_1.Message.getRepeatedWrapperField(this, HintProto, 4) as HintProto[];
    }
    set hints(value: HintProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    get prompt() {
        return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
    }
    set prompt(value: string) {
        pb_1.Message.setField(this, 5, value);
    }
    get negativePrompt() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set negativePrompt(value: string) {
        pb_1.Message.setField(this, 6, value);
    }
    get configuration() {
        return pb_1.Message.getFieldWithDefault(this, 7, new Uint8Array(0)) as Uint8Array;
    }
    set configuration(value: Uint8Array) {
        pb_1.Message.setField(this, 7, value);
    }
    get override() {
        return pb_1.Message.getWrapperField(this, MetadataOverride, 8) as MetadataOverride;
    }
    set override(value: MetadataOverride) {
        pb_1.Message.setWrapperField(this, 8, value);
    }
    get has_override() {
        return pb_1.Message.getField(this, 8) != null;
    }
    get keywords() {
        return pb_1.Message.getFieldWithDefault(this, 9, []) as string[];
    }
    set keywords(value: string[]) {
        pb_1.Message.setField(this, 9, value);
    }
    get user() {
        return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
    }
    set user(value: string) {
        pb_1.Message.setField(this, 10, value);
    }
    get device() {
        return pb_1.Message.getFieldWithDefault(this, 11, DeviceType.PHONE) as DeviceType;
    }
    set device(value: DeviceType) {
        pb_1.Message.setField(this, 11, value);
    }
    get contents() {
        return pb_1.Message.getFieldWithDefault(this, 12, []) as Uint8Array[];
    }
    set contents(value: Uint8Array[]) {
        pb_1.Message.setField(this, 12, value);
    }
    get sharedSecret() {
        return pb_1.Message.getFieldWithDefault(this, 13, "") as string;
    }
    set sharedSecret(value: string) {
        pb_1.Message.setOneofField(this, 13, this.#one_of_decls[2], value);
    }
    get has_sharedSecret() {
        return pb_1.Message.getField(this, 13) != null;
    }
    get _image() {
        const cases: {
            [index: number]: "none" | "image";
        } = {
            0: "none",
            1: "image"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _mask() {
        const cases: {
            [index: number]: "none" | "mask";
        } = {
            0: "none",
            3: "mask"
        };
        return cases[pb_1.Message.computeOneofCase(this, [3])];
    }
    get _sharedSecret() {
        const cases: {
            [index: number]: "none" | "sharedSecret";
        } = {
            0: "none",
            13: "sharedSecret"
        };
        return cases[pb_1.Message.computeOneofCase(this, [13])];
    }
    static fromObject(data: {
        image?: Uint8Array;
        scaleFactor?: number;
        mask?: Uint8Array;
        hints?: ReturnType<typeof HintProto.prototype.toObject>[];
        prompt?: string;
        negativePrompt?: string;
        configuration?: Uint8Array;
        override?: ReturnType<typeof MetadataOverride.prototype.toObject>;
        keywords?: string[];
        user?: string;
        device?: DeviceType;
        contents?: Uint8Array[];
        sharedSecret?: string;
    }): ImageGenerationRequest {
        const message = new ImageGenerationRequest({});
        if (data.image != null) {
            message.image = data.image;
        }
        if (data.scaleFactor != null) {
            message.scaleFactor = data.scaleFactor;
        }
        if (data.mask != null) {
            message.mask = data.mask;
        }
        if (data.hints != null) {
            message.hints = data.hints.map(item => HintProto.fromObject(item));
        }
        if (data.prompt != null) {
            message.prompt = data.prompt;
        }
        if (data.negativePrompt != null) {
            message.negativePrompt = data.negativePrompt;
        }
        if (data.configuration != null) {
            message.configuration = data.configuration;
        }
        if (data.override != null) {
            message.override = MetadataOverride.fromObject(data.override);
        }
        if (data.keywords != null) {
            message.keywords = data.keywords;
        }
        if (data.user != null) {
            message.user = data.user;
        }
        if (data.device != null) {
            message.device = data.device;
        }
        if (data.contents != null) {
            message.contents = data.contents;
        }
        if (data.sharedSecret != null) {
            message.sharedSecret = data.sharedSecret;
        }
        return message;
    }
    toObject() {
        const data: {
            image?: Uint8Array;
            scaleFactor?: number;
            mask?: Uint8Array;
            hints?: ReturnType<typeof HintProto.prototype.toObject>[];
            prompt?: string;
            negativePrompt?: string;
            configuration?: Uint8Array;
            override?: ReturnType<typeof MetadataOverride.prototype.toObject>;
            keywords?: string[];
            user?: string;
            device?: DeviceType;
            contents?: Uint8Array[];
            sharedSecret?: string;
        } = {};
        if (this.image != null) {
            data.image = this.image;
        }
        if (this.scaleFactor != null) {
            data.scaleFactor = this.scaleFactor;
        }
        if (this.mask != null) {
            data.mask = this.mask;
        }
        if (this.hints != null) {
            data.hints = this.hints.map((item: HintProto) => item.toObject());
        }
        if (this.prompt != null) {
            data.prompt = this.prompt;
        }
        if (this.negativePrompt != null) {
            data.negativePrompt = this.negativePrompt;
        }
        if (this.configuration != null) {
            data.configuration = this.configuration;
        }
        if (this.override != null) {
            data.override = this.override.toObject();
        }
        if (this.keywords != null) {
            data.keywords = this.keywords;
        }
        if (this.user != null) {
            data.user = this.user;
        }
        if (this.device != null) {
            data.device = this.device;
        }
        if (this.contents != null) {
            data.contents = this.contents;
        }
        if (this.sharedSecret != null) {
            data.sharedSecret = this.sharedSecret;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_image)
            writer.writeBytes(1, this.image);
        if (this.scaleFactor != 0)
            writer.writeInt32(2, this.scaleFactor);
        if (this.has_mask)
            writer.writeBytes(3, this.mask);
        if (this.hints.length)
            writer.writeRepeatedMessage(4, this.hints, (item: HintProto) => item.serialize(writer));
        if (this.prompt.length)
            writer.writeString(5, this.prompt);
        if (this.negativePrompt.length)
            writer.writeString(6, this.negativePrompt);
        if (this.configuration.length)
            writer.writeBytes(7, this.configuration);
        if (this.has_override)
            writer.writeMessage(8, this.override, () => this.override.serialize(writer));
        if (this.keywords.length)
            writer.writeRepeatedString(9, this.keywords);
        if (this.user.length)
            writer.writeString(10, this.user);
        if (this.device != DeviceType.PHONE)
            writer.writeEnum(11, this.device);
        if (this.contents.length)
            writer.writeRepeatedBytes(12, this.contents);
        if (this.has_sharedSecret)
            writer.writeString(13, this.sharedSecret);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImageGenerationRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImageGenerationRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.image = reader.readBytes();
                    break;
                case 2:
                    message.scaleFactor = reader.readInt32();
                    break;
                case 3:
                    message.mask = reader.readBytes();
                    break;
                case 4:
                    reader.readMessage(message.hints, () => pb_1.Message.addToRepeatedWrapperField(message, 4, HintProto.deserialize(reader), HintProto));
                    break;
                case 5:
                    message.prompt = reader.readString();
                    break;
                case 6:
                    message.negativePrompt = reader.readString();
                    break;
                case 7:
                    message.configuration = reader.readBytes();
                    break;
                case 8:
                    reader.readMessage(message.override, () => message.override = MetadataOverride.deserialize(reader));
                    break;
                case 9:
                    pb_1.Message.addToRepeatedField(message, 9, reader.readString());
                    break;
                case 10:
                    message.user = reader.readString();
                    break;
                case 11:
                    message.device = reader.readEnum();
                    break;
                case 12:
                    pb_1.Message.addToRepeatedField(message, 12, reader.readBytes());
                    break;
                case 13:
                    message.sharedSecret = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ImageGenerationRequest {
        return ImageGenerationRequest.deserialize(bytes);
    }
}
export class HintProto extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        hintType?: string;
        tensors?: TensorAndWeight[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("hintType" in data && data.hintType != undefined) {
                this.hintType = data.hintType;
            }
            if ("tensors" in data && data.tensors != undefined) {
                this.tensors = data.tensors;
            }
        }
    }
    get hintType() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set hintType(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get tensors() {
        return pb_1.Message.getRepeatedWrapperField(this, TensorAndWeight, 2) as TensorAndWeight[];
    }
    set tensors(value: TensorAndWeight[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
        hintType?: string;
        tensors?: ReturnType<typeof TensorAndWeight.prototype.toObject>[];
    }): HintProto {
        const message = new HintProto({});
        if (data.hintType != null) {
            message.hintType = data.hintType;
        }
        if (data.tensors != null) {
            message.tensors = data.tensors.map(item => TensorAndWeight.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            hintType?: string;
            tensors?: ReturnType<typeof TensorAndWeight.prototype.toObject>[];
        } = {};
        if (this.hintType != null) {
            data.hintType = this.hintType;
        }
        if (this.tensors != null) {
            data.tensors = this.tensors.map((item: TensorAndWeight) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hintType.length)
            writer.writeString(1, this.hintType);
        if (this.tensors.length)
            writer.writeRepeatedMessage(2, this.tensors, (item: TensorAndWeight) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): HintProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new HintProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.hintType = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.tensors, () => pb_1.Message.addToRepeatedWrapperField(message, 2, TensorAndWeight.deserialize(reader), TensorAndWeight));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): HintProto {
        return HintProto.deserialize(bytes);
    }
}
export class TensorAndWeight extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        tensor?: Uint8Array;
        weight?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("tensor" in data && data.tensor != undefined) {
                this.tensor = data.tensor;
            }
            if ("weight" in data && data.weight != undefined) {
                this.weight = data.weight;
            }
        }
    }
    get tensor() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
    }
    set tensor(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get weight() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set weight(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        tensor?: Uint8Array;
        weight?: number;
    }): TensorAndWeight {
        const message = new TensorAndWeight({});
        if (data.tensor != null) {
            message.tensor = data.tensor;
        }
        if (data.weight != null) {
            message.weight = data.weight;
        }
        return message;
    }
    toObject() {
        const data: {
            tensor?: Uint8Array;
            weight?: number;
        } = {};
        if (this.tensor != null) {
            data.tensor = this.tensor;
        }
        if (this.weight != null) {
            data.weight = this.weight;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.tensor.length)
            writer.writeBytes(1, this.tensor);
        if (this.weight != 0)
            writer.writeFloat(2, this.weight);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TensorAndWeight {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TensorAndWeight();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.tensor = reader.readBytes();
                    break;
                case 2:
                    message.weight = reader.readFloat();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TensorAndWeight {
        return TensorAndWeight.deserialize(bytes);
    }
}
export class ImageGenerationSignpostProto extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6, 7, 8, 9]];
    constructor(data?: any[] | ({} & (({
        textEncoded?: ImageGenerationSignpostProto.TextEncoded;
        imageEncoded?: never;
        sampling?: never;
        imageDecoded?: never;
        secondPassImageEncoded?: never;
        secondPassSampling?: never;
        secondPassImageDecoded?: never;
        faceRestored?: never;
        imageUpscaled?: never;
    } | {
        textEncoded?: never;
        imageEncoded?: ImageGenerationSignpostProto.ImageEncoded;
        sampling?: never;
        imageDecoded?: never;
        secondPassImageEncoded?: never;
        secondPassSampling?: never;
        secondPassImageDecoded?: never;
        faceRestored?: never;
        imageUpscaled?: never;
    } | {
        textEncoded?: never;
        imageEncoded?: never;
        sampling?: ImageGenerationSignpostProto.Sampling;
        imageDecoded?: never;
        secondPassImageEncoded?: never;
        secondPassSampling?: never;
        secondPassImageDecoded?: never;
        faceRestored?: never;
        imageUpscaled?: never;
    } | {
        textEncoded?: never;
        imageEncoded?: never;
        sampling?: never;
        imageDecoded?: ImageGenerationSignpostProto.ImageDecoded;
        secondPassImageEncoded?: never;
        secondPassSampling?: never;
        secondPassImageDecoded?: never;
        faceRestored?: never;
        imageUpscaled?: never;
    } | {
        textEncoded?: never;
        imageEncoded?: never;
        sampling?: never;
        imageDecoded?: never;
        secondPassImageEncoded?: ImageGenerationSignpostProto.SecondPassImageEncoded;
        secondPassSampling?: never;
        secondPassImageDecoded?: never;
        faceRestored?: never;
        imageUpscaled?: never;
    } | {
        textEncoded?: never;
        imageEncoded?: never;
        sampling?: never;
        imageDecoded?: never;
        secondPassImageEncoded?: never;
        secondPassSampling?: ImageGenerationSignpostProto.SecondPassSampling;
        secondPassImageDecoded?: never;
        faceRestored?: never;
        imageUpscaled?: never;
    } | {
        textEncoded?: never;
        imageEncoded?: never;
        sampling?: never;
        imageDecoded?: never;
        secondPassImageEncoded?: never;
        secondPassSampling?: never;
        secondPassImageDecoded?: ImageGenerationSignpostProto.SecondPassImageDecoded;
        faceRestored?: never;
        imageUpscaled?: never;
    } | {
        textEncoded?: never;
        imageEncoded?: never;
        sampling?: never;
        imageDecoded?: never;
        secondPassImageEncoded?: never;
        secondPassSampling?: never;
        secondPassImageDecoded?: never;
        faceRestored?: ImageGenerationSignpostProto.FaceRestored;
        imageUpscaled?: never;
    } | {
        textEncoded?: never;
        imageEncoded?: never;
        sampling?: never;
        imageDecoded?: never;
        secondPassImageEncoded?: never;
        secondPassSampling?: never;
        secondPassImageDecoded?: never;
        faceRestored?: never;
        imageUpscaled?: ImageGenerationSignpostProto.ImageUpscaled;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("textEncoded" in data && data.textEncoded != undefined) {
                this.textEncoded = data.textEncoded;
            }
            if ("imageEncoded" in data && data.imageEncoded != undefined) {
                this.imageEncoded = data.imageEncoded;
            }
            if ("sampling" in data && data.sampling != undefined) {
                this.sampling = data.sampling;
            }
            if ("imageDecoded" in data && data.imageDecoded != undefined) {
                this.imageDecoded = data.imageDecoded;
            }
            if ("secondPassImageEncoded" in data && data.secondPassImageEncoded != undefined) {
                this.secondPassImageEncoded = data.secondPassImageEncoded;
            }
            if ("secondPassSampling" in data && data.secondPassSampling != undefined) {
                this.secondPassSampling = data.secondPassSampling;
            }
            if ("secondPassImageDecoded" in data && data.secondPassImageDecoded != undefined) {
                this.secondPassImageDecoded = data.secondPassImageDecoded;
            }
            if ("faceRestored" in data && data.faceRestored != undefined) {
                this.faceRestored = data.faceRestored;
            }
            if ("imageUpscaled" in data && data.imageUpscaled != undefined) {
                this.imageUpscaled = data.imageUpscaled;
            }
        }
    }
    get textEncoded() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto.TextEncoded, 1) as ImageGenerationSignpostProto.TextEncoded;
    }
    set textEncoded(value: ImageGenerationSignpostProto.TextEncoded) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_textEncoded() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get imageEncoded() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto.ImageEncoded, 2) as ImageGenerationSignpostProto.ImageEncoded;
    }
    set imageEncoded(value: ImageGenerationSignpostProto.ImageEncoded) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_imageEncoded() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get sampling() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto.Sampling, 3) as ImageGenerationSignpostProto.Sampling;
    }
    set sampling(value: ImageGenerationSignpostProto.Sampling) {
        pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_sampling() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get imageDecoded() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto.ImageDecoded, 4) as ImageGenerationSignpostProto.ImageDecoded;
    }
    set imageDecoded(value: ImageGenerationSignpostProto.ImageDecoded) {
        pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_imageDecoded() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get secondPassImageEncoded() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto.SecondPassImageEncoded, 5) as ImageGenerationSignpostProto.SecondPassImageEncoded;
    }
    set secondPassImageEncoded(value: ImageGenerationSignpostProto.SecondPassImageEncoded) {
        pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
    }
    get has_secondPassImageEncoded() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get secondPassSampling() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto.SecondPassSampling, 6) as ImageGenerationSignpostProto.SecondPassSampling;
    }
    set secondPassSampling(value: ImageGenerationSignpostProto.SecondPassSampling) {
        pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
    }
    get has_secondPassSampling() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get secondPassImageDecoded() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto.SecondPassImageDecoded, 7) as ImageGenerationSignpostProto.SecondPassImageDecoded;
    }
    set secondPassImageDecoded(value: ImageGenerationSignpostProto.SecondPassImageDecoded) {
        pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
    }
    get has_secondPassImageDecoded() {
        return pb_1.Message.getField(this, 7) != null;
    }
    get faceRestored() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto.FaceRestored, 8) as ImageGenerationSignpostProto.FaceRestored;
    }
    set faceRestored(value: ImageGenerationSignpostProto.FaceRestored) {
        pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
    }
    get has_faceRestored() {
        return pb_1.Message.getField(this, 8) != null;
    }
    get imageUpscaled() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto.ImageUpscaled, 9) as ImageGenerationSignpostProto.ImageUpscaled;
    }
    set imageUpscaled(value: ImageGenerationSignpostProto.ImageUpscaled) {
        pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
    }
    get has_imageUpscaled() {
        return pb_1.Message.getField(this, 9) != null;
    }
    get signpost() {
        const cases: {
            [index: number]: "none" | "textEncoded" | "imageEncoded" | "sampling" | "imageDecoded" | "secondPassImageEncoded" | "secondPassSampling" | "secondPassImageDecoded" | "faceRestored" | "imageUpscaled";
        } = {
            0: "none",
            1: "textEncoded",
            2: "imageEncoded",
            3: "sampling",
            4: "imageDecoded",
            5: "secondPassImageEncoded",
            6: "secondPassSampling",
            7: "secondPassImageDecoded",
            8: "faceRestored",
            9: "imageUpscaled"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9])];
    }
    static fromObject(data: {
        textEncoded?: ReturnType<typeof ImageGenerationSignpostProto.TextEncoded.prototype.toObject>;
        imageEncoded?: ReturnType<typeof ImageGenerationSignpostProto.ImageEncoded.prototype.toObject>;
        sampling?: ReturnType<typeof ImageGenerationSignpostProto.Sampling.prototype.toObject>;
        imageDecoded?: ReturnType<typeof ImageGenerationSignpostProto.ImageDecoded.prototype.toObject>;
        secondPassImageEncoded?: ReturnType<typeof ImageGenerationSignpostProto.SecondPassImageEncoded.prototype.toObject>;
        secondPassSampling?: ReturnType<typeof ImageGenerationSignpostProto.SecondPassSampling.prototype.toObject>;
        secondPassImageDecoded?: ReturnType<typeof ImageGenerationSignpostProto.SecondPassImageDecoded.prototype.toObject>;
        faceRestored?: ReturnType<typeof ImageGenerationSignpostProto.FaceRestored.prototype.toObject>;
        imageUpscaled?: ReturnType<typeof ImageGenerationSignpostProto.ImageUpscaled.prototype.toObject>;
    }): ImageGenerationSignpostProto {
        const message = new ImageGenerationSignpostProto({});
        if (data.textEncoded != null) {
            message.textEncoded = ImageGenerationSignpostProto.TextEncoded.fromObject(data.textEncoded);
        }
        if (data.imageEncoded != null) {
            message.imageEncoded = ImageGenerationSignpostProto.ImageEncoded.fromObject(data.imageEncoded);
        }
        if (data.sampling != null) {
            message.sampling = ImageGenerationSignpostProto.Sampling.fromObject(data.sampling);
        }
        if (data.imageDecoded != null) {
            message.imageDecoded = ImageGenerationSignpostProto.ImageDecoded.fromObject(data.imageDecoded);
        }
        if (data.secondPassImageEncoded != null) {
            message.secondPassImageEncoded = ImageGenerationSignpostProto.SecondPassImageEncoded.fromObject(data.secondPassImageEncoded);
        }
        if (data.secondPassSampling != null) {
            message.secondPassSampling = ImageGenerationSignpostProto.SecondPassSampling.fromObject(data.secondPassSampling);
        }
        if (data.secondPassImageDecoded != null) {
            message.secondPassImageDecoded = ImageGenerationSignpostProto.SecondPassImageDecoded.fromObject(data.secondPassImageDecoded);
        }
        if (data.faceRestored != null) {
            message.faceRestored = ImageGenerationSignpostProto.FaceRestored.fromObject(data.faceRestored);
        }
        if (data.imageUpscaled != null) {
            message.imageUpscaled = ImageGenerationSignpostProto.ImageUpscaled.fromObject(data.imageUpscaled);
        }
        return message;
    }
    toObject() {
        const data: {
            textEncoded?: ReturnType<typeof ImageGenerationSignpostProto.TextEncoded.prototype.toObject>;
            imageEncoded?: ReturnType<typeof ImageGenerationSignpostProto.ImageEncoded.prototype.toObject>;
            sampling?: ReturnType<typeof ImageGenerationSignpostProto.Sampling.prototype.toObject>;
            imageDecoded?: ReturnType<typeof ImageGenerationSignpostProto.ImageDecoded.prototype.toObject>;
            secondPassImageEncoded?: ReturnType<typeof ImageGenerationSignpostProto.SecondPassImageEncoded.prototype.toObject>;
            secondPassSampling?: ReturnType<typeof ImageGenerationSignpostProto.SecondPassSampling.prototype.toObject>;
            secondPassImageDecoded?: ReturnType<typeof ImageGenerationSignpostProto.SecondPassImageDecoded.prototype.toObject>;
            faceRestored?: ReturnType<typeof ImageGenerationSignpostProto.FaceRestored.prototype.toObject>;
            imageUpscaled?: ReturnType<typeof ImageGenerationSignpostProto.ImageUpscaled.prototype.toObject>;
        } = {};
        if (this.textEncoded != null) {
            data.textEncoded = this.textEncoded.toObject();
        }
        if (this.imageEncoded != null) {
            data.imageEncoded = this.imageEncoded.toObject();
        }
        if (this.sampling != null) {
            data.sampling = this.sampling.toObject();
        }
        if (this.imageDecoded != null) {
            data.imageDecoded = this.imageDecoded.toObject();
        }
        if (this.secondPassImageEncoded != null) {
            data.secondPassImageEncoded = this.secondPassImageEncoded.toObject();
        }
        if (this.secondPassSampling != null) {
            data.secondPassSampling = this.secondPassSampling.toObject();
        }
        if (this.secondPassImageDecoded != null) {
            data.secondPassImageDecoded = this.secondPassImageDecoded.toObject();
        }
        if (this.faceRestored != null) {
            data.faceRestored = this.faceRestored.toObject();
        }
        if (this.imageUpscaled != null) {
            data.imageUpscaled = this.imageUpscaled.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_textEncoded)
            writer.writeMessage(1, this.textEncoded, () => this.textEncoded.serialize(writer));
        if (this.has_imageEncoded)
            writer.writeMessage(2, this.imageEncoded, () => this.imageEncoded.serialize(writer));
        if (this.has_sampling)
            writer.writeMessage(3, this.sampling, () => this.sampling.serialize(writer));
        if (this.has_imageDecoded)
            writer.writeMessage(4, this.imageDecoded, () => this.imageDecoded.serialize(writer));
        if (this.has_secondPassImageEncoded)
            writer.writeMessage(5, this.secondPassImageEncoded, () => this.secondPassImageEncoded.serialize(writer));
        if (this.has_secondPassSampling)
            writer.writeMessage(6, this.secondPassSampling, () => this.secondPassSampling.serialize(writer));
        if (this.has_secondPassImageDecoded)
            writer.writeMessage(7, this.secondPassImageDecoded, () => this.secondPassImageDecoded.serialize(writer));
        if (this.has_faceRestored)
            writer.writeMessage(8, this.faceRestored, () => this.faceRestored.serialize(writer));
        if (this.has_imageUpscaled)
            writer.writeMessage(9, this.imageUpscaled, () => this.imageUpscaled.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImageGenerationSignpostProto {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImageGenerationSignpostProto();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.textEncoded, () => message.textEncoded = ImageGenerationSignpostProto.TextEncoded.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.imageEncoded, () => message.imageEncoded = ImageGenerationSignpostProto.ImageEncoded.deserialize(reader));
                    break;
                case 3:
                    reader.readMessage(message.sampling, () => message.sampling = ImageGenerationSignpostProto.Sampling.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.imageDecoded, () => message.imageDecoded = ImageGenerationSignpostProto.ImageDecoded.deserialize(reader));
                    break;
                case 5:
                    reader.readMessage(message.secondPassImageEncoded, () => message.secondPassImageEncoded = ImageGenerationSignpostProto.SecondPassImageEncoded.deserialize(reader));
                    break;
                case 6:
                    reader.readMessage(message.secondPassSampling, () => message.secondPassSampling = ImageGenerationSignpostProto.SecondPassSampling.deserialize(reader));
                    break;
                case 7:
                    reader.readMessage(message.secondPassImageDecoded, () => message.secondPassImageDecoded = ImageGenerationSignpostProto.SecondPassImageDecoded.deserialize(reader));
                    break;
                case 8:
                    reader.readMessage(message.faceRestored, () => message.faceRestored = ImageGenerationSignpostProto.FaceRestored.deserialize(reader));
                    break;
                case 9:
                    reader.readMessage(message.imageUpscaled, () => message.imageUpscaled = ImageGenerationSignpostProto.ImageUpscaled.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ImageGenerationSignpostProto {
        return ImageGenerationSignpostProto.deserialize(bytes);
    }
}
export namespace ImageGenerationSignpostProto {
    export class TextEncoded extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): TextEncoded {
            const message = new TextEncoded({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TextEncoded {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TextEncoded();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TextEncoded {
            return TextEncoded.deserialize(bytes);
        }
    }
    export class ImageEncoded extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): ImageEncoded {
            const message = new ImageEncoded({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImageEncoded {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImageEncoded();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ImageEncoded {
            return ImageEncoded.deserialize(bytes);
        }
    }
    export class Sampling extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            step?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("step" in data && data.step != undefined) {
                    this.step = data.step;
                }
            }
        }
        get step() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set step(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            step?: number;
        }): Sampling {
            const message = new Sampling({});
            if (data.step != null) {
                message.step = data.step;
            }
            return message;
        }
        toObject() {
            const data: {
                step?: number;
            } = {};
            if (this.step != null) {
                data.step = this.step;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.step != 0)
                writer.writeInt32(1, this.step);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Sampling {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Sampling();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.step = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Sampling {
            return Sampling.deserialize(bytes);
        }
    }
    export class ImageDecoded extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): ImageDecoded {
            const message = new ImageDecoded({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImageDecoded {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImageDecoded();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ImageDecoded {
            return ImageDecoded.deserialize(bytes);
        }
    }
    export class SecondPassImageEncoded extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): SecondPassImageEncoded {
            const message = new SecondPassImageEncoded({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SecondPassImageEncoded {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SecondPassImageEncoded();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SecondPassImageEncoded {
            return SecondPassImageEncoded.deserialize(bytes);
        }
    }
    export class SecondPassSampling extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            step?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("step" in data && data.step != undefined) {
                    this.step = data.step;
                }
            }
        }
        get step() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set step(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            step?: number;
        }): SecondPassSampling {
            const message = new SecondPassSampling({});
            if (data.step != null) {
                message.step = data.step;
            }
            return message;
        }
        toObject() {
            const data: {
                step?: number;
            } = {};
            if (this.step != null) {
                data.step = this.step;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.step != 0)
                writer.writeInt32(1, this.step);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SecondPassSampling {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SecondPassSampling();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.step = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SecondPassSampling {
            return SecondPassSampling.deserialize(bytes);
        }
    }
    export class SecondPassImageDecoded extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): SecondPassImageDecoded {
            const message = new SecondPassImageDecoded({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SecondPassImageDecoded {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SecondPassImageDecoded();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SecondPassImageDecoded {
            return SecondPassImageDecoded.deserialize(bytes);
        }
    }
    export class FaceRestored extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): FaceRestored {
            const message = new FaceRestored({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FaceRestored {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FaceRestored();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FaceRestored {
            return FaceRestored.deserialize(bytes);
        }
    }
    export class ImageUpscaled extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): ImageUpscaled {
            const message = new ImageUpscaled({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImageUpscaled {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImageUpscaled();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ImageUpscaled {
            return ImageUpscaled.deserialize(bytes);
        }
    }
}
export class ImageGenerationResponse extends pb_1.Message {
    #one_of_decls: number[][] = [[2], [4], [5]];
    constructor(data?: any[] | ({
        generatedImages?: Uint8Array[];
        signposts?: ImageGenerationSignpostProto[];
        tags?: string[];
    } & (({
        currentSignpost?: ImageGenerationSignpostProto;
    }) | ({
        previewImage?: Uint8Array;
    }) | ({
        scaleFactor?: number;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 3, 6], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("generatedImages" in data && data.generatedImages != undefined) {
                this.generatedImages = data.generatedImages;
            }
            if ("currentSignpost" in data && data.currentSignpost != undefined) {
                this.currentSignpost = data.currentSignpost;
            }
            if ("signposts" in data && data.signposts != undefined) {
                this.signposts = data.signposts;
            }
            if ("previewImage" in data && data.previewImage != undefined) {
                this.previewImage = data.previewImage;
            }
            if ("scaleFactor" in data && data.scaleFactor != undefined) {
                this.scaleFactor = data.scaleFactor;
            }
            if ("tags" in data && data.tags != undefined) {
                this.tags = data.tags;
            }
        }
    }
    get generatedImages() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as Uint8Array[];
    }
    set generatedImages(value: Uint8Array[]) {
        pb_1.Message.setField(this, 1, value);
    }
    get currentSignpost() {
        return pb_1.Message.getWrapperField(this, ImageGenerationSignpostProto, 2) as ImageGenerationSignpostProto;
    }
    set currentSignpost(value: ImageGenerationSignpostProto) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_currentSignpost() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get signposts() {
        return pb_1.Message.getRepeatedWrapperField(this, ImageGenerationSignpostProto, 3) as ImageGenerationSignpostProto[];
    }
    set signposts(value: ImageGenerationSignpostProto[]) {
        pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    get previewImage() {
        return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
    }
    set previewImage(value: Uint8Array) {
        pb_1.Message.setOneofField(this, 4, this.#one_of_decls[1], value);
    }
    get has_previewImage() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get scaleFactor() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set scaleFactor(value: number) {
        pb_1.Message.setOneofField(this, 5, this.#one_of_decls[2], value);
    }
    get has_scaleFactor() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get tags() {
        return pb_1.Message.getFieldWithDefault(this, 6, []) as string[];
    }
    set tags(value: string[]) {
        pb_1.Message.setField(this, 6, value);
    }
    get _currentSignpost() {
        const cases: {
            [index: number]: "none" | "currentSignpost";
        } = {
            0: "none",
            2: "currentSignpost"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    get _previewImage() {
        const cases: {
            [index: number]: "none" | "previewImage";
        } = {
            0: "none",
            4: "previewImage"
        };
        return cases[pb_1.Message.computeOneofCase(this, [4])];
    }
    get _scaleFactor() {
        const cases: {
            [index: number]: "none" | "scaleFactor";
        } = {
            0: "none",
            5: "scaleFactor"
        };
        return cases[pb_1.Message.computeOneofCase(this, [5])];
    }
    static fromObject(data: {
        generatedImages?: Uint8Array[];
        currentSignpost?: ReturnType<typeof ImageGenerationSignpostProto.prototype.toObject>;
        signposts?: ReturnType<typeof ImageGenerationSignpostProto.prototype.toObject>[];
        previewImage?: Uint8Array;
        scaleFactor?: number;
        tags?: string[];
    }): ImageGenerationResponse {
        const message = new ImageGenerationResponse({});
        if (data.generatedImages != null) {
            message.generatedImages = data.generatedImages;
        }
        if (data.currentSignpost != null) {
            message.currentSignpost = ImageGenerationSignpostProto.fromObject(data.currentSignpost);
        }
        if (data.signposts != null) {
            message.signposts = data.signposts.map(item => ImageGenerationSignpostProto.fromObject(item));
        }
        if (data.previewImage != null) {
            message.previewImage = data.previewImage;
        }
        if (data.scaleFactor != null) {
            message.scaleFactor = data.scaleFactor;
        }
        if (data.tags != null) {
            message.tags = data.tags;
        }
        return message;
    }
    toObject() {
        const data: {
            generatedImages?: Uint8Array[];
            currentSignpost?: ReturnType<typeof ImageGenerationSignpostProto.prototype.toObject>;
            signposts?: ReturnType<typeof ImageGenerationSignpostProto.prototype.toObject>[];
            previewImage?: Uint8Array;
            scaleFactor?: number;
            tags?: string[];
        } = {};
        if (this.generatedImages != null) {
            data.generatedImages = this.generatedImages;
        }
        if (this.currentSignpost != null) {
            data.currentSignpost = this.currentSignpost.toObject();
        }
        if (this.signposts != null) {
            data.signposts = this.signposts.map((item: ImageGenerationSignpostProto) => item.toObject());
        }
        if (this.previewImage != null) {
            data.previewImage = this.previewImage;
        }
        if (this.scaleFactor != null) {
            data.scaleFactor = this.scaleFactor;
        }
        if (this.tags != null) {
            data.tags = this.tags;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.generatedImages.length)
            writer.writeRepeatedBytes(1, this.generatedImages);
        if (this.has_currentSignpost)
            writer.writeMessage(2, this.currentSignpost, () => this.currentSignpost.serialize(writer));
        if (this.signposts.length)
            writer.writeRepeatedMessage(3, this.signposts, (item: ImageGenerationSignpostProto) => item.serialize(writer));
        if (this.has_previewImage)
            writer.writeBytes(4, this.previewImage);
        if (this.has_scaleFactor)
            writer.writeInt32(5, this.scaleFactor);
        if (this.tags.length)
            writer.writeRepeatedString(6, this.tags);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImageGenerationResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImageGenerationResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readBytes());
                    break;
                case 2:
                    reader.readMessage(message.currentSignpost, () => message.currentSignpost = ImageGenerationSignpostProto.deserialize(reader));
                    break;
                case 3:
                    reader.readMessage(message.signposts, () => pb_1.Message.addToRepeatedWrapperField(message, 3, ImageGenerationSignpostProto.deserialize(reader), ImageGenerationSignpostProto));
                    break;
                case 4:
                    message.previewImage = reader.readBytes();
                    break;
                case 5:
                    message.scaleFactor = reader.readInt32();
                    break;
                case 6:
                    pb_1.Message.addToRepeatedField(message, 6, reader.readString());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ImageGenerationResponse {
        return ImageGenerationResponse.deserialize(bytes);
    }
}
export class FileChunk extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        content?: Uint8Array;
        filename?: string;
        offset?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("content" in data && data.content != undefined) {
                this.content = data.content;
            }
            if ("filename" in data && data.filename != undefined) {
                this.filename = data.filename;
            }
            if ("offset" in data && data.offset != undefined) {
                this.offset = data.offset;
            }
        }
    }
    get content() {
        return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
    }
    set content(value: Uint8Array) {
        pb_1.Message.setField(this, 1, value);
    }
    get filename() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set filename(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get offset() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set offset(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        content?: Uint8Array;
        filename?: string;
        offset?: number;
    }): FileChunk {
        const message = new FileChunk({});
        if (data.content != null) {
            message.content = data.content;
        }
        if (data.filename != null) {
            message.filename = data.filename;
        }
        if (data.offset != null) {
            message.offset = data.offset;
        }
        return message;
    }
    toObject() {
        const data: {
            content?: Uint8Array;
            filename?: string;
            offset?: number;
        } = {};
        if (this.content != null) {
            data.content = this.content;
        }
        if (this.filename != null) {
            data.filename = this.filename;
        }
        if (this.offset != null) {
            data.offset = this.offset;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.content.length)
            writer.writeBytes(1, this.content);
        if (this.filename.length)
            writer.writeString(2, this.filename);
        if (this.offset != 0)
            writer.writeInt64(3, this.offset);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileChunk {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileChunk();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.content = reader.readBytes();
                    break;
                case 2:
                    message.filename = reader.readString();
                    break;
                case 3:
                    message.offset = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FileChunk {
        return FileChunk.deserialize(bytes);
    }
}
export class InitUploadRequest extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        filename?: string;
        sha256?: Uint8Array;
        totalSize?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("filename" in data && data.filename != undefined) {
                this.filename = data.filename;
            }
            if ("sha256" in data && data.sha256 != undefined) {
                this.sha256 = data.sha256;
            }
            if ("totalSize" in data && data.totalSize != undefined) {
                this.totalSize = data.totalSize;
            }
        }
    }
    get filename() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set filename(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get sha256() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
    }
    set sha256(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get totalSize() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set totalSize(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        filename?: string;
        sha256?: Uint8Array;
        totalSize?: number;
    }): InitUploadRequest {
        const message = new InitUploadRequest({});
        if (data.filename != null) {
            message.filename = data.filename;
        }
        if (data.sha256 != null) {
            message.sha256 = data.sha256;
        }
        if (data.totalSize != null) {
            message.totalSize = data.totalSize;
        }
        return message;
    }
    toObject() {
        const data: {
            filename?: string;
            sha256?: Uint8Array;
            totalSize?: number;
        } = {};
        if (this.filename != null) {
            data.filename = this.filename;
        }
        if (this.sha256 != null) {
            data.sha256 = this.sha256;
        }
        if (this.totalSize != null) {
            data.totalSize = this.totalSize;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.filename.length)
            writer.writeString(1, this.filename);
        if (this.sha256.length)
            writer.writeBytes(2, this.sha256);
        if (this.totalSize != 0)
            writer.writeInt64(3, this.totalSize);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): InitUploadRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new InitUploadRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.filename = reader.readString();
                    break;
                case 2:
                    message.sha256 = reader.readBytes();
                    break;
                case 3:
                    message.totalSize = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): InitUploadRequest {
        return InitUploadRequest.deserialize(bytes);
    }
}
export class UploadResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        chunkUploadSuccess?: boolean;
        receivedOffset?: number;
        message?: string;
        filename?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("chunkUploadSuccess" in data && data.chunkUploadSuccess != undefined) {
                this.chunkUploadSuccess = data.chunkUploadSuccess;
            }
            if ("receivedOffset" in data && data.receivedOffset != undefined) {
                this.receivedOffset = data.receivedOffset;
            }
            if ("message" in data && data.message != undefined) {
                this.message = data.message;
            }
            if ("filename" in data && data.filename != undefined) {
                this.filename = data.filename;
            }
        }
    }
    get chunkUploadSuccess() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set chunkUploadSuccess(value: boolean) {
        pb_1.Message.setField(this, 1, value);
    }
    get receivedOffset() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set receivedOffset(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get message() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set message(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get filename() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set filename(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
        chunkUploadSuccess?: boolean;
        receivedOffset?: number;
        message?: string;
        filename?: string;
    }): UploadResponse {
        const message = new UploadResponse({});
        if (data.chunkUploadSuccess != null) {
            message.chunkUploadSuccess = data.chunkUploadSuccess;
        }
        if (data.receivedOffset != null) {
            message.receivedOffset = data.receivedOffset;
        }
        if (data.message != null) {
            message.message = data.message;
        }
        if (data.filename != null) {
            message.filename = data.filename;
        }
        return message;
    }
    toObject() {
        const data: {
            chunkUploadSuccess?: boolean;
            receivedOffset?: number;
            message?: string;
            filename?: string;
        } = {};
        if (this.chunkUploadSuccess != null) {
            data.chunkUploadSuccess = this.chunkUploadSuccess;
        }
        if (this.receivedOffset != null) {
            data.receivedOffset = this.receivedOffset;
        }
        if (this.message != null) {
            data.message = this.message;
        }
        if (this.filename != null) {
            data.filename = this.filename;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.chunkUploadSuccess != false)
            writer.writeBool(1, this.chunkUploadSuccess);
        if (this.receivedOffset != 0)
            writer.writeInt64(2, this.receivedOffset);
        if (this.message.length)
            writer.writeString(3, this.message);
        if (this.filename.length)
            writer.writeString(4, this.filename);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UploadResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UploadResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.chunkUploadSuccess = reader.readBool();
                    break;
                case 2:
                    message.receivedOffset = reader.readInt64();
                    break;
                case 3:
                    message.message = reader.readString();
                    break;
                case 4:
                    message.filename = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): UploadResponse {
        return UploadResponse.deserialize(bytes);
    }
}
export class FileUploadRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2], [3]];
    constructor(data?: any[] | ({} & (({
        initRequest?: InitUploadRequest;
        chunk?: never;
    } | {
        initRequest?: never;
        chunk?: FileChunk;
    }) | ({
        sharedSecret?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("initRequest" in data && data.initRequest != undefined) {
                this.initRequest = data.initRequest;
            }
            if ("chunk" in data && data.chunk != undefined) {
                this.chunk = data.chunk;
            }
            if ("sharedSecret" in data && data.sharedSecret != undefined) {
                this.sharedSecret = data.sharedSecret;
            }
        }
    }
    get initRequest() {
        return pb_1.Message.getWrapperField(this, InitUploadRequest, 1) as InitUploadRequest;
    }
    set initRequest(value: InitUploadRequest) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_initRequest() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get chunk() {
        return pb_1.Message.getWrapperField(this, FileChunk, 2) as FileChunk;
    }
    set chunk(value: FileChunk) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_chunk() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get sharedSecret() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set sharedSecret(value: string) {
        pb_1.Message.setOneofField(this, 3, this.#one_of_decls[1], value);
    }
    get has_sharedSecret() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get request() {
        const cases: {
            [index: number]: "none" | "initRequest" | "chunk";
        } = {
            0: "none",
            1: "initRequest",
            2: "chunk"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
    }
    get _sharedSecret() {
        const cases: {
            [index: number]: "none" | "sharedSecret";
        } = {
            0: "none",
            3: "sharedSecret"
        };
        return cases[pb_1.Message.computeOneofCase(this, [3])];
    }
    static fromObject(data: {
        initRequest?: ReturnType<typeof InitUploadRequest.prototype.toObject>;
        chunk?: ReturnType<typeof FileChunk.prototype.toObject>;
        sharedSecret?: string;
    }): FileUploadRequest {
        const message = new FileUploadRequest({});
        if (data.initRequest != null) {
            message.initRequest = InitUploadRequest.fromObject(data.initRequest);
        }
        if (data.chunk != null) {
            message.chunk = FileChunk.fromObject(data.chunk);
        }
        if (data.sharedSecret != null) {
            message.sharedSecret = data.sharedSecret;
        }
        return message;
    }
    toObject() {
        const data: {
            initRequest?: ReturnType<typeof InitUploadRequest.prototype.toObject>;
            chunk?: ReturnType<typeof FileChunk.prototype.toObject>;
            sharedSecret?: string;
        } = {};
        if (this.initRequest != null) {
            data.initRequest = this.initRequest.toObject();
        }
        if (this.chunk != null) {
            data.chunk = this.chunk.toObject();
        }
        if (this.sharedSecret != null) {
            data.sharedSecret = this.sharedSecret;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_initRequest)
            writer.writeMessage(1, this.initRequest, () => this.initRequest.serialize(writer));
        if (this.has_chunk)
            writer.writeMessage(2, this.chunk, () => this.chunk.serialize(writer));
        if (this.has_sharedSecret)
            writer.writeString(3, this.sharedSecret);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileUploadRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileUploadRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.initRequest, () => message.initRequest = InitUploadRequest.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.chunk, () => message.chunk = FileChunk.deserialize(reader));
                    break;
                case 3:
                    message.sharedSecret = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FileUploadRequest {
        return FileUploadRequest.deserialize(bytes);
    }
}
interface GrpcUnaryServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
}
interface GrpcStreamServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
}
interface GrpWritableServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
}
interface GrpcChunkServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
}
interface GrpcPromiseServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
    (message: P, options?: grpc_1.CallOptions): Promise<R>;
}
export abstract class UnimplementedImageGenerationServiceService {
    static definition = {
        GenerateImage: {
            path: "/ImageGenerationService/GenerateImage",
            requestStream: false,
            responseStream: true,
            requestSerialize: (message: ImageGenerationRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => ImageGenerationRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: ImageGenerationResponse) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => ImageGenerationResponse.deserialize(new Uint8Array(bytes))
        },
        FilesExist: {
            path: "/ImageGenerationService/FilesExist",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: FileListRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => FileListRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: FileExistenceResponse) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => FileExistenceResponse.deserialize(new Uint8Array(bytes))
        },
        UploadFile: {
            path: "/ImageGenerationService/UploadFile",
            requestStream: true,
            responseStream: true,
            requestSerialize: (message: FileUploadRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => FileUploadRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: UploadResponse) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => UploadResponse.deserialize(new Uint8Array(bytes))
        },
        Echo: {
            path: "/ImageGenerationService/Echo",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: EchoRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => EchoRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: EchoReply) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => EchoReply.deserialize(new Uint8Array(bytes))
        }
    };
    [method: string]: grpc_1.UntypedHandleCall;
    abstract GenerateImage(call: grpc_1.ServerWritableStream<ImageGenerationRequest, ImageGenerationResponse>): void;
    abstract FilesExist(call: grpc_1.ServerUnaryCall<FileListRequest, FileExistenceResponse>, callback: grpc_1.sendUnaryData<FileExistenceResponse>): void;
    abstract UploadFile(call: grpc_1.ServerDuplexStream<FileUploadRequest, UploadResponse>): void;
    abstract Echo(call: grpc_1.ServerUnaryCall<EchoRequest, EchoReply>, callback: grpc_1.sendUnaryData<EchoReply>): void;
}
export class ImageGenerationServiceClient extends grpc_1.makeGenericClientConstructor(UnimplementedImageGenerationServiceService.definition, "ImageGenerationService", {}) {
    constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
        super(address, credentials, options);
    }
    GenerateImage: GrpcStreamServiceInterface<ImageGenerationRequest, ImageGenerationResponse> = (message: ImageGenerationRequest, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<ImageGenerationResponse> => {
        return super.GenerateImage(message, metadata, options);
    };
    FilesExist: GrpcUnaryServiceInterface<FileListRequest, FileExistenceResponse> = (message: FileListRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<FileExistenceResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<FileExistenceResponse>, callback?: grpc_1.requestCallback<FileExistenceResponse>): grpc_1.ClientUnaryCall => {
        return super.FilesExist(message, metadata, options, callback);
    };
    UploadFile: GrpcChunkServiceInterface<FileUploadRequest, UploadResponse> = (metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<FileUploadRequest, UploadResponse> => {
        return super.UploadFile(metadata, options);
    };
    Echo: GrpcUnaryServiceInterface<EchoRequest, EchoReply> = (message: EchoRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<EchoReply>, options?: grpc_1.CallOptions | grpc_1.requestCallback<EchoReply>, callback?: grpc_1.requestCallback<EchoReply>): grpc_1.ClientUnaryCall => {
        return super.Echo(message, metadata, options, callback);
    };
}
